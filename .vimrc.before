" let mapleader = ","
"call janus#disable_plugin('easymotion')

set lazyredraw
set modelines=0

" Highlight VCS conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" System clipboard interaction
" From https://github.com/henrik/dotfiles/blob/master/vim/config/mappings.vim
noremap <leader>y "*y
noremap <leader>p :set paste<CR>"*p<CR>:set nopaste<CR>
noremap <leader>P :set paste<CR>"*P<CR>:set nopaste<CR>

" Clean trailing whitespace
nnoremap <leader>w mz:%s/\s\+$//<cr>:let @/=''<cr>`z

" Better Completion
set completeopt=longest,menuone,preview

" Save when losing focus
au FocusLost * :silent! wall

" Resize splits when the window is resized
au VimResized * :wincmd =

" Cursorline {{{
" Only show cursorline in the current window and in normal mode.

augroup cline
    au!
    au WinLeave * set nocursorline
    au WinEnter * set cursorline
    au InsertEnter * set nocursorline
    au InsertLeave * set cursorline
augroup END

" }}}

" Trailing whitespace {{{
" Only shown when not in insert mode so I don't go insane.

augroup trailing
    au!
    au InsertEnter * :set listchars-=trail:⌴
    au InsertLeave * :set listchars+=trail:⌴
augroup END

" }}}

let g:Powerline_symbols = 'fancy'

set undodir=~/.janus/tmp/undo//     " undo files
set backupdir=~/.janus/tmp/backup// " backups
set directory=~/.janus/tmp/swap//   " swap files
set backup                        " enable backups
set noswapfile                    " It's 2012, Vim.

let g:buffergator_viewport_split_policy = "T"
let g:buffergator_split_size = 8

let g:syntastic_enable_signs = 1
let g:syntastic_check_on_open = 1

let NERDTreeMinimalUI=1
let NERDTreeShowBookmarks=1
let NERDTreeChDirMode=2
"let NERDTreeWinPos="right"

:map <F4> [I:let nr = input("Which one: ")<Bar>exe "normal " . nr ."[\t"<CR>

" Folding ----------------------------------------------------------------- {{{

set foldlevelstart=1

" Space to toggle folds.
nnoremap <Space> za
vnoremap <Space> za

" Make zO recursively open whatever top level fold we're in, no matter where the
" cursor happens to be.
nnoremap zO zCzO

function! MyFoldText() " {{{
    let line = getline(v:foldstart)

    let nucolwidth = &fdc + &number * &numberwidth
    let windowwidth = winwidth(0) - nucolwidth - 3
    let foldedlinecount = v:foldend - v:foldstart

    " expand tabs into spaces
    let onetab = strpart('          ', 0, &tabstop)
    let line = substitute(line, '\t', onetab, 'g')

    let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
    let fillcharcount = windowwidth - len(line) - len(foldedlinecount)
    return line . '…' . repeat(" ",fillcharcount) . foldedlinecount . '…' . ' '
endfunction " }}}
set foldtext=MyFoldText()

" }}}

" Ruby {{{

augroup ft_ruby
    au!
    au Filetype ruby setlocal foldmethod=syntax
augroup END

" }}}


" Indent Guides {{{

let g:indentguides_state = 0
function! IndentGuides() " {{{
    if g:indentguides_state
        let g:indentguides_state = 0
        2match None
    else
        let g:indentguides_state = 1
      :w  execute '2match IndentGuides /\%(\_^\s*\)\@<=\%(\%'.(0*&sw+1).'v\|\%'.(1*&sw+1).'v\|\%'.(2*&sw+1).'v\|\%'.(3*&sw+1).'v\|\%'.(4*&sw+1).'v\|\%'.(5*&sw+1).'v\|\%'.(6*&sw+1).'v\|\%'.(7*&sw+1).'v\)\s/'
    endif
endfunction " }}}
hi def IndentGuides guibg=#303030
nnoremap <leader>I :call IndentGuides()<cr>

" }}}

" Block Colors {{{

let g:blockcolor_state = 0
function! BlockColor() " {{{
    if g:blockcolor_state
        let g:blockcolor_state = 0
        call matchdelete(77881)
        call matchdelete(77882)
        call matchdelete(77883)
        call matchdelete(77884)
        call matchdelete(77885)
    else
        let g:blockcolor_state = 1
        call matchadd("BlockColor1", '^ \{4}.*', 1, 77881)
        call matchadd("BlockColor2", '^ \{8}.*', 2, 77882)
        call matchadd("BlockColor3", '^ \{12}.*', 3, 77883)
        call matchadd("BlockColor4", '^ \{16}.*', 4, 77884)
        call matchadd("BlockColor5", '^ \{20}.*', 5, 77885)
    endif
endfunction " }}}
" Default highlights {{{
hi def BlockColor1 guibg=#222222
hi def BlockColor2 guibg=#2a2a2a
hi def BlockColor3 guibg=#353535
hi def BlockColor4 guibg=#3d3d3d
hi def BlockColor5 guibg=#444444
" }}}
nnoremap <leader>B :call BlockColor()<cr>

" }}}

" }}}

set tags=./tags,tags,~/github/ruby/tags

if has('gui_running')
  set guifont=LetterGothicMonoOT-Regular\ for\ Powerline:h17

  set guioptions-=M
  set guioptions-=T
  set guioptions-=r
  set guioptions-=l
  set guioptions-=L

  if has("gui_macvim")
    set fuoptions=maxvert,maxhorz
  else
    " non macvim gui
  end
else
    " Console Vim
    " For me, this means iTerm2, possibly through tmux

    " Mouse support
    set mouse=a

    " iTerm2 allows you to turn "focus reporting" on and off with these
    " sequences.
    "
    " When reporting is on, iTerm2 will send <Esc>[O when the window loses
    " focus and <Esc>[I when it gains focus.
    "
    " TODO: Look into how this works with iTerm tabs.  Seems a bit wonky.
    let enable_focus_reporting  = "\<Esc>[?1004h"
    let disable_focus_reporting = "\<Esc>[?1004l"

    " These sequences save/restore the screen.
    " They should NOT be wrapped in tmux escape sequences for some reason!
    let save_screen    = "\<Esc>[?1049h"
    let restore_screen = "\<Esc>[?1049l"

    " These sequences tell iTerm2 to change the cursor shape to a bar or block.
    let cursor_to_bar   = "\<Esc>]50;CursorShape=1\x7"
    let cursor_to_block = "\<Esc>]50;CursorShape=0\x7"

    if exists('$TMUX')
        " Some escape sequences (not all, lol) need to be properly escaped to
        " get them through tmux without being eaten.
        "
        " To escape a sequence through tmux:
        "
        " * Wrap it in these sequences.
        " * Any <Esc> characters inside it must be doubled.
        let tmux_start = "\<Esc>Ptmux;"
        let tmux_end   = "\<Esc>\\"

        let enable_focus_reporting  = tmux_start . "\<Esc>" . enable_focus_reporting  . tmux_end
        let disable_focus_reporting = tmux_start . "\<Esc>" . disable_focus_reporting . tmux_end

        let cursor_to_bar   = tmux_start . "\<Esc>" . cursor_to_bar   . tmux_end
        let cursor_to_block = tmux_start . "\<Esc>" . cursor_to_block . tmux_end
    endif

    " When starting Vim, enable focus reporting and save the screen.
    " When exiting Vim, disable focus reporting and save the screen.
    "
    " The "focus/save" and "nofocus/restore" each have to be in this order.
    " Trust me, you don't want to go down this rabbit hole.  Just keep them in
    " this order and no one gets hurt.
    let &t_ti = enable_focus_reporting . save_screen
    let &t_te = disable_focus_reporting . restore_screen

    " When entering insert mode, change the cursor to a bar.
    " When exiting insert mode, change it back to a block.
    let &t_SI = cursor_to_bar
    let &t_EI = cursor_to_block

    " Map some of Vim's unused keycodes to the sequences iTerm2 is going to send
    " on focus lost/gained.
    "
    " If you're already using f24 or f25, change them to something else.  Vim
    " support up to f37.
    "
    " Doing things this way is might nicer than just mapping the raw sequences
    " directly, because Vim won't hang after a bare <Esc> waiting for the rest
    " of the mapping.
    execute "set <f24>=\<Esc>[O"
    execute "set <f25>=\<Esc>[I"

    " Handle the focus gained/lost signals in each mode separately.
    "
    " The goal is to fire the autocmd and restore the state as cleanly as
    " possible.  This is easy for some modes and hard/impossible for others.
    "
    " EXAMPLES:
    nnoremap <silent> <f24> :doautocmd FocusLost %<cr>
    nnoremap <silent> <f25> :doautocmd FocusGained %<cr>

    onoremap <silent> <f24> <esc>:doautocmd FocusLost %<cr>
    onoremap <silent> <f25> <esc>:doautocmd FocusGained %<cr>

    vnoremap <silent> <f24> <esc>:doautocmd FocusLost %<cr>gv
    vnoremap <silent> <f25> <esc>:doautocmd FocusGained %<cr>gv

    inoremap <silent> <f24> <c-o>:doautocmd FocusLost %<cr>
    inoremap <silent> <f25> <c-o>:doautocmd FocusGained %<cr>
endif

" }}}

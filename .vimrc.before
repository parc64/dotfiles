let mapleader = ","
" set lazyredraw
set modelines=0
set splitbelow
set splitright

set notimeout
set ttimeout
set ttimeoutlen=10
set encoding=utf-8

set noeb vb t_vb=
au GUIEnter * set vb t_vb=

set wildmenu
set wildmode=list:longest

set wildignore+=.hg,.git,.svn                    " Version control
set wildignore+=*.aux,*.out,*.toc                " LaTeX intermediate files
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg   " binary images
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.spl                            " compiled spelling word lists
set wildignore+=*.sw?                            " Vim swap files
set wildignore+=*.DS_Store                       " OSX bullshit

au BufNewFile,BufRead *.jsonify set filetype=ruby

map <C-h> <C-w>h
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-l> <C-w>l

" Clean trailing whitespace
nnoremap <leader>w mz:%s/\s\+$//<cr>:let @/=''<cr>`z

" Better Completion
set completeopt=longest,menuone,preview

" Save when losing focus
" au FocusLost * :silent! wall

" Resize splits when the window is resized
"au VimResized * :wincmd =

let g:Powerline_symbols = 'fancy'

set undodir=~/.janus/tmp/undo//     " undo files
set backupdir=~/.janus/tmp/backup// " backups
set directory=~/.janus/tmp/swap//   " swap files
set backup                        " enable backups
set noswapfile                    " It's 2012, Vim.

let g:buffergator_viewport_split_policy = "T"
let g:buffergator_split_size = 8

let g:syntastic_enable_signs = 1
let g:syntastic_check_on_open = 1

noremap  <F2> :NERDTreeToggle<cr>
inoremap <F2> <esc>:NERDTreeToggle<cr>

let NERDTreeMinimalUI=1
let NERDTreeShowBookmarks=1
let NERDTreeChDirMode=2
"let NERDTreeWinPos="right"

:map <F3> [I:let nr = input("--> ")<Bar>exe "normal " . nr ."[\t"<CR>

set number
nnoremap <F6> :set nonumber!<CR>

set tags=./tags,tags,~/github/ruby/tags,~/github/rails/tags

if has('gui_running')
  set guifont=LetterGothicMonoOT-Light\ for\ Powerline:h17

  set guioptions-=M
  set guioptions-=T
  set guioptions-=r
  set guioptions-=l
  set guioptions-=L

  if has("gui_macvim")
    set fuoptions=maxvert,maxhorz
  else
    " non macvim gui
  end
else
    " Console Vim
    " For me, this means iTerm2, possibly through tmux

    " Mouse support
    set mouse=a

    " iTerm2 allows you to turn "focus reporting" on and off with these
    " sequences.
    "
    " When reporting is on, iTerm2 will send <Esc>[O when the window loses
    " focus and <Esc>[I when it gains focus.
    "
    " TODO: Look into how this works with iTerm tabs.  Seems a bit wonky.
    let enable_focus_reporting  = "\<Esc>[?1004h"
    let disable_focus_reporting = "\<Esc>[?1004l"

    " These sequences save/restore the screen.
    " They should NOT be wrapped in tmux escape sequences for some reason!
    let save_screen    = "\<Esc>[?1049h"
    let restore_screen = "\<Esc>[?1049l"

    " These sequences tell iTerm2 to change the cursor shape to a bar or block.
    let cursor_to_bar   = "\<Esc>]50;CursorShape=1\x7"
    let cursor_to_block = "\<Esc>]50;CursorShape=0\x7"

    if exists('$TMUX')
        " Some escape sequences (not all, lol) need to be properly escaped to
        " get them through tmux without being eaten.
        "
        " To escape a sequence through tmux:
        "
        " * Wrap it in these sequences.
        " * Any <Esc> characters inside it must be doubled.
        let tmux_start = "\<Esc>Ptmux;"
        let tmux_end   = "\<Esc>\\"

        let enable_focus_reporting  = tmux_start . "\<Esc>" . enable_focus_reporting  . tmux_end
        let disable_focus_reporting = tmux_start . "\<Esc>" . disable_focus_reporting . tmux_end

        let cursor_to_bar   = tmux_start . "\<Esc>" . cursor_to_bar   . tmux_end
        let cursor_to_block = tmux_start . "\<Esc>" . cursor_to_block . tmux_end
    endif

    " When starting Vim, enable focus reporting and save the screen.
    " When exiting Vim, disable focus reporting and save the screen.
    "
    " The "focus/save" and "nofocus/restore" each have to be in this order.
    " Trust me, you don't want to go down this rabbit hole.  Just keep them in
    " this order and no one gets hurt.
    let &t_ti = enable_focus_reporting . save_screen
    let &t_te = disable_focus_reporting . restore_screen

    " When entering insert mode, change the cursor to a bar.
    " When exiting insert mode, change it back to a block.
    let &t_SI = cursor_to_bar
    let &t_EI = cursor_to_block

    " Map some of Vim's unused keycodes to the sequences iTerm2 is going to send
    " on focus lost/gained.
    "
    " If you're already using f24 or f25, change them to something else.  Vim
    " support up to f37.
    "
    " Doing things this way is might nicer than just mapping the raw sequences
    " directly, because Vim won't hang after a bare <Esc> waiting for the rest
    " of the mapping.
    execute "set <f24>=\<Esc>[O"
    execute "set <f25>=\<Esc>[I"

    " Handle the focus gained/lost signals in each mode separately.
    "
    " The goal is to fire the autocmd and restore the state as cleanly as
    " possible.  This is easy for some modes and hard/impossible for others.
    "
    " EXAMPLES:
    nnoremap <silent> <f24> :doautocmd FocusLost %<cr>
    nnoremap <silent> <f25> :doautocmd FocusGained %<cr>

    onoremap <silent> <f24> <esc>:doautocmd FocusLost %<cr>
    onoremap <silent> <f25> <esc>:doautocmd FocusGained %<cr>

    vnoremap <silent> <f24> <esc>:doautocmd FocusLost %<cr>gv
    vnoremap <silent> <f25> <esc>:doautocmd FocusGained %<cr>gv

    inoremap <silent> <f24> <c-o>:doautocmd FocusLost %<cr>
    inoremap <silent> <f25> <c-o>:doautocmd FocusGained %<cr>
endif

" compile vim from source on OSX to get this feature, use system ruby
" ./configure --enable-rubyinterp --enable-multibyte --with-features=huge
set clipboard=unnamed

" Highlight VCS conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" Only show cursorline in the current window and in normal mode.
augroup cline
    au!
    au WinLeave * set nocursorline
    au WinEnter * set cursorline
    au InsertEnter * set nocursorline
    au InsertLeave * set cursorline
augroup END

if has('gui_running')
  set guifont=LetterGothicMonoOT-Light\ for\ Powerline:h19

  set guioptions-=M
  set guioptions-=T
  set guioptions-=r
  set guioptions-=l
  set guioptions-=L

  if has("gui_macvim")
    set fuoptions=maxvert,maxhorz
  else
    " non macvim gui
  end
else
    " Console Vim
    " For me, this means iTerm2, possibly through tmux

    " Mouse support
    set mouse=a

    " iTerm2 allows you to turn "focus reporting" on and off with these
    " sequences.
    "
    " When reporting is on, iTerm2 will send <Esc>[O when the window loses
    " focus and <Esc>[I when it gains focus.
    "
    " TODO: Look into how this works with iTerm tabs.  Seems a bit wonky.
    let enable_focus_reporting  = "\<Esc>[?1004h"
    let disable_focus_reporting = "\<Esc>[?1004l"

    " These sequences save/restore the screen.
    " They should NOT be wrapped in tmux escape sequences for some reason!
    let save_screen    = "\<Esc>[?1049h"
    let restore_screen = "\<Esc>[?1049l"

    " These sequences tell iTerm2 to change the cursor shape to a bar or block.
    let cursor_to_bar   = "\<Esc>]50;CursorShape=1\x7"
    let cursor_to_block = "\<Esc>]50;CursorShape=0\x7"

    if exists('$TMUX')
        " Some escape sequences (not all, lol) need to be properly escaped to
        " get them through tmux without being eaten.
        "
        " To escape a sequence through tmux:
        "
        " * Wrap it in these sequences.
        " * Any <Esc> characters inside it must be doubled.
        let tmux_start = "\<Esc>Ptmux;"
        let tmux_end   = "\<Esc>\\"

        let enable_focus_reporting  = tmux_start . "\<Esc>" . enable_focus_reporting  . tmux_end
        let disable_focus_reporting = tmux_start . "\<Esc>" . disable_focus_reporting . tmux_end

        let cursor_to_bar   = tmux_start . "\<Esc>" . cursor_to_bar   . tmux_end
        let cursor_to_block = tmux_start . "\<Esc>" . cursor_to_block . tmux_end
    endif

    " When starting Vim, enable focus reporting and save the screen.
    " When exiting Vim, disable focus reporting and save the screen.
    "
    " The "focus/save" and "nofocus/restore" each have to be in this order.
    " Trust me, you don't want to go down this rabbit hole.  Just keep them in
    " this order and no one gets hurt.
    let &t_ti = enable_focus_reporting . save_screen
    let &t_te = disable_focus_reporting . restore_screen

    " When entering insert mode, change the cursor to a bar.
    " When exiting insert mode, change it back to a block.
    let &t_SI = cursor_to_bar
    let &t_EI = cursor_to_block

    " Map some of Vim's unused keycodes to the sequences iTerm2 is going to send
    " on focus lost/gained.
    "
    " If you're already using f24 or f25, change them to something else.  Vim
    " support up to f37.
    "
    " Doing things this way is might nicer than just mapping the raw sequences
    " directly, because Vim won't hang after a bare <Esc> waiting for the rest
    " of the mapping.
    execute "set <f24>=\<Esc>[O"
    execute "set <f25>=\<Esc>[I"

    " Handle the focus gained/lost signals in each mode separately.
    "
    " The goal is to fire the autocmd and restore the state as cleanly as
    " possible.  This is easy for some modes and hard/impossible for others.
    "
    " EXAMPLES:
    nnoremap <silent> <f24> :doautocmd FocusLost %<cr>
    nnoremap <silent> <f25> :doautocmd FocusGained %<cr>

    onoremap <silent> <f24> <esc>:doautocmd FocusLost %<cr>
    onoremap <silent> <f25> <esc>:doautocmd FocusGained %<cr>

    vnoremap <silent> <f24> <esc>:doautocmd FocusLost %<cr>gv
    vnoremap <silent> <f25> <esc>:doautocmd FocusGained %<cr>gv

    inoremap <silent> <f24> <c-o>:doautocmd FocusLost %<cr>
    inoremap <silent> <f25> <c-o>:doautocmd FocusGained %<cr>
endif



set background=dark
if has("gui_macvim")
  set transparency=5
end
set nonumber
color jellybeans+

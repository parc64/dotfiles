require "noesis_math"
class Outcome < ActiveRecord::Base
  include Math
  include NoesisMath

  establish_connection :market_service_db

  belongs_to :question
  has_many :holdings

  #    # ###### #      #####  ###### #####   ####
  #    # #      #      #    # #      #    # #
  ###### #####  #      #    # #####  #    #  ####
  #    # #      #      #####  #      #####       #
  #    # #      #      #      #      #   #  #    #
  #    # ###### ###### #      ###### #    #  ####


  def all_held_shares
    total = big_decimalize(0)
    self.holdings.each do |h|
      total += big_decimalize(h.quantity)
    end
    total
  end

  def beta
    big_decimalize(question.beta)
  end

  def epsilon
    big_decimalize(question.epsilon)
  end

  def cost_to_buy(n_shares)
    h,n = big_decimalize(all_held_shares, n_shares)
    cost(h + n) - cost(h)
  end

  def cost_to_sell(n_shares)
    h,n = big_decimalize(all_held_shares, n_shares)
    cost(h - n) - cost(h)
  end

  def score
    h = all_held_shares
    price(h)
  end

  def max_shares_for_cash(cash_amount)
    cash, h, = big_decimalize(cash_amount, all_held_shares)
    bigF = lambda { |n| cost_to_buy(n) - cash }
    f = lambda { |n| price(h + n) }
    num_shares = newton_raphson(bigF, f, 1, epsilon)

    # Ensure that we are not buying more than the user requested
    while (cost_to_buy(num_shares) > cash_amount) do
      num_shares -= epsilon
    end
    num_shares
  end

  def min_shares_for_cash(cash_amount)
    cash, h = big_decimalize(cash_amount, all_held_shares)
    bigF = lambda { |n| cost_to_sell(n) + cash }
    f = lambda { |n| -price(h - n) }
    num_shares = newton_raphson(bigF, f, 1, epsilon)

    # Ensure that we are not cashing out more than the user requested
    while (cost_to_sell(num_shares) < -cash_amount) do
      num_shares -= epsilon
    end
    num_shares
  end


##### #####    ##   #####  # #    #  ####
  #   #    #  #  #  #    # # ##   # #    #
  #   #    # #    # #    # # # #  # #
  #   #####  ###### #    # # #  # # #  ###
  #   #   #  #    # #    # # #   ## #    #
  #   #    # #    # #####  # #    #  ####

  def buy(cash_amount_to_invest, user_id)
    bank_account = BankAccount.find_by_user_id(user_id)
    cash_amount_to_invest = [bank_account.balance, cash_amount_to_invest].min
    num_shares_requested = max_shares_for_cash(cash_amount_to_invest)

    transfer_holdings_to_user(num_shares_requested, cash_amount_to_invest,user_id)
  end

  def sell(cash_amount_to_extract, user_id)
    num_shares_needed = min_shares_for_cash(cash_amount_to_extract)
    num_shares_held   = Holding.num_shares_held(user_id, id)
    num_shares_to_ditch = [num_shares_held, num_shares_needed].min

    transfer_holdings_to_market_maker(num_shares_to_ditch, cash_amount_to_extract, user_id)
  end

  def cash_out(user_id)
    num_shares_held = Holding.num_shares_held(user_id, id)
    transfer_holdings_to_market_maker(num_shares_held, -cost_to_sell(num_shares_held), user_id)
  end

  def change_position(goal_position, user_id)
    current_position = Holding.current_value_of_investment(user_id, id)
    goal_position, current_position = big_decimalize(goal_position, current_position)
    position_change = goal_position - current_position
    if (position_change > 0)
      buy(position_change, user_id)
    else
      sell(-position_change, user_id)
    end
  end

  private

  def transfer_holdings_to_user(n_shares, cash_amount, user_id)
    question.market_maker.guarantee_holdings_exist(n_shares, id)
    transfer_holdings_and_cash(n_shares, -cash_amount,  user_id)
  end

  def transfer_holdings_to_market_maker(n_shares, cash_amount, user_id)
    # user loses holdings and gains cash
    cash_amount_transferred = transfer_holdings_and_cash(-n_shares, cash_amount, user_id)
    question.market_maker.gaurantee_holdings_vanish(id)
    cash_amount_transferred
  end

  def transfer_holdings_and_cash(n_shares, cash_amount, user_id)
    users_bank_account = BankAccount.find_by_user_id(user_id)
    market_maker = question.market_maker

    users_bank_account.balance += cash_amount
    market_maker.balance -= cash_amount

    # TODO: remove crappy defensive programming. Buy & Sell should throw exceptions or do something explicit when they get orders for zero shares
    cost_basis = (n_shares == 0.0) ? 0.0 : cash_amount.to_f / n_shares
    self.holdings.create(:user_id =>              user_id, :quantity =>  n_shares, :cost_basis => cost_basis, :cash_value =>  cash_amount)
    self.holdings.create(:user_id => MarketMaker::USER_ID, :quantity => -n_shares, :cost_basis => cost_basis, :cash_value => -cash_amount)

    self.last_trade_price = self.score
    self.save!

    users_bank_account.save!
    market_maker.save!
    cash_amount
  end

  def cost(x)
    x,e = big_decimalize(x,E) # e must be BigDecimalized for the ** operator to function
    mu = mean(shares_held_for_siblings + [x])
    log_argument = e**((x - mu)/beta)
    shares_held_for_siblings.each do |n_shares|
      log_argument += e**((n_shares - mu)/beta)
    end
    beta * log(log_argument) #TODO: use BigMath.log instead
  end

  def price(x)
    x,e = big_decimalize(x,E)
    mu = mean(shares_held_for_siblings + [x])
    denominator = e**((x - mu)/beta)
    shares_held_for_siblings.each do |n_shares|
      denominator += e**((n_shares - mu)/beta)
    end
    e**((x - mu)/beta) / (denominator)
  end

  def price(x)
    h1 = x 
    h2 = siblings.first.all_held_shares
binding.pry
    1 / (1 + e**((h2 - h1) / beta))
  end


   ####  # #####  #      # #    #  ####   ####
  #      # #    # #      # ##   # #    # #
   ####  # #####  #      # # #  # #       ####
       # # #    # #      # #  # # #  ###      #
  #    # # #    # #      # #   ## #    # #    #
   ####  # #####  ###### # #    #  ####   ####


  def self_and_siblings
    question ? question.outcomes : self.class.roots
  end

  def siblings
    self_and_siblings - [self]
  end

  def shares_held_for_self_and_siblings
    self_and_siblings.collect do |s|
      s.all_held_shares
    end
  end

  def shares_held_for_siblings
    siblings.collect do |s|
      s.all_held_shares
    end
  end
end
